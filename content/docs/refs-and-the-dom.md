---
id: refs-and-the-dom
title: Refs and the DOM
redirect_from:
  - "docs/working-with-the-browser.html"
  - "docs/more-about-refs.html"
  - "docs/more-about-refs-ko-KR.html"
  - "docs/more-about-refs-zh-CN.html"
  - "tips/expose-component-functions.html"
  - "tips/children-undefined.html"
permalink: docs/refs-and-the-dom.html
---

Рефи надають доступ до DOM-вузлів чи React-елементів, що створюються під час рендеру.

У звичайному потоці даних React батьківські компоненти можуть взаємодіяти з дітьми тільки через [пропси](/docs/components-and-props.html). Щоб модифікувати нащадка, ви маєте повторно відрендерити його з новими пропсами. Проте існують ситуації, коли вам потрібно імперативно змінити нащадка поза звичайного потоку даних. Нащадок, щоб бути зміненим, має бути екземпляром React-компонента або DOM-елементом. В обох випадках React надає можливість обійти звичайний потік даних.

### Коли використовувати рефи {#when-to-use-refs}

Існує декілька ситуацій, коли доцільно використовувати рефи:

* Контроль фокусу, виділення тексту чи контроль програвання медіа.
* Виклик імперативної анімації.
* Інтеграція зі сторонніми DOM-бібліотеками.

Уникайте використання рефів для будь-чого, що можна зробити декларативно.

Наприклад, замість виклику методів `open()` та `close()` компоненту `Dialog`, передайте йому проп `isOpen`.

### Не зловживайте рефами {#dont-overuse-refs}

Мабуть першим вашим бажанням буде використовувати рефи для того, щоб "все працювало" у вашому додатку. Якщо це так, зупиніться та подумайте більш критично про те, який з компонентів в ієрархії має контролювати стан. Зазвичай, стає зрозуміло, що правильне місце для контролю стану лежить на верхніх рівнях ієрархії. Більш детально ознайомтеся з розділом [Підняття стану](/docs/lifting-state-up.html) для прикладів такої поведінки.

> Примітка
>
> Приклади нижче були оновлені для використання `React.createRef()` API, що з'явилося у React 16.3. Якщо ви користуєтеся більш старішою версією React, ми рекомендуємо використувати [рефи зворотнього виклику](#callback-refs).

### Створення рефів {#creating-refs}

Рефи створюються за допомогою виклику методу `React.createRef()` та приєднюються до React-елемента через атрибут `ref`. Рефи зазвичай зберігають як властивість екземпляра компонента під час створення, для того щоб мати доступ до рефа у будь-якому методі компонента.

```javascript{4,7}
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}
```

### Доступ до рефів {#accessing-refs}

Коли реф передається елементу в методі `render`, ви отримуєте доступ до посилання на вузол через властивість `.current` цього рефа.

```javascript
const node = this.myRef.current;
```

Значення рефа може відрізнятися в залежності від типу вузла:

- Коли атрибут `ref` визначений у HTML-елемента, тоді `ref`, що створений у конструкторі за допомогою методу `React.createRef()`, отримує доступ до відповідого DOM-елемента через свою властивість `.current`.
- Коли атрибут `ref` визначений у компонента користувача, тоді об'єкт `ref` у свою властивість `.current` отримує посилання на вмонтований екземпляр компонента.
- **Заборонено використовувати атрибут `ref` до функціональних компонентах**, тому що у них немає екземплярів.

На прикладах нижче можна побачити різницю.

#### Застосування рефу до DOM-елемента {#adding-a-ref-to-a-dom-element}

Код нижче використовує `ref`, щоб отримати посилання на DOM-вузол:

```javascript{5,12,22}
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // створимо реф, щоб отримати посилання на DOM-елемент поля введення
    this.textInput = React.createRef();
    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    // Переведемо фокус на текстове поле введення, використовуючи нативне DOM API
    // Примітка: ми використовуємо "current", щоб отримати DOM-вузол
    this.textInput.current.focus();
  }

  render() {
    // вкажемо React, що ми хочемо зв'язати реф елемента <input>
    // з `textInput`, що був визначений в конструкторі
    return (
      <div>
        <input
          type="text"
          ref={this.textInput} />
        <input
          type="button"
          value="Перенести фокус на текстове поле введення"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
```

React зв'яже властивість `.current` з DOM-елементом, коли компонент буде вмонтований, та встановить назад в `null`, коли компонент буде прибрано з DOM. Оновлення `ref` відбувається перед `componentDidMount` або `componentDidUpdate`.

#### Застосування рефу до компонента {#adding-a-ref-to-a-class-component}

Якби ми захотіли обернути попередній компонент `CustomTextInput`, щоб симулювати натискання по ньому одразу після вмонтування, ми могли б використати реф, щоб отримати доступ до користувацького поля введення та виклакати його метод `focusTextInput` напряму:

```javascript{4,8,13}
class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }

  componentDidMount() {
    this.textInput.current.focusTextInput();
  }

  render() {
    return (
      <CustomTextInput ref={this.textInput} />
    );
  }
}
```

Зауважте, що це працює тільки, якщо `CustomTextInput` визначений як клас:

```js{1}
class CustomTextInput extends React.Component {
  // ...
}
```

#### Рефи та функціональні компоненти {#refs-and-function-components}

**Заборонено застосовувати атрибут `ref` до функціональних компонентів**, тому що у них немає екзеплярів:

```javascript{1,8,13}
function MyFunctionComponent() {
  return <input />;
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }
  render() {
    // Це *не* буде працювати!
    return (
      <MyFunctionComponent ref={this.textInput} />
    );
  }
}
```

Ви маєте перетворити компонент в клас, якщо ви хочете скористатися рефом, так само як ви б робили, коли вам потрібні методи життєвого циклу або стан.

Проте ви можете **використовувати атрибут `ref` в середині функціональних компонентів** за умови, що ви визначаєте їх на DOM-елементах або класових компонентах:

```javascript{2,3,6,13}
function CustomTextInput(props) {
  // textInput повинен бути визначений тут, щоб реф міг посилатися на нього
  let textInput = React.createRef();

  function handleClick() {
    textInput.current.focus();
  }

  return (
    <div>
      <input
        type="text"
        ref={textInput} />
      <input
        type="button"
        value="Перенести фокус на текстове поле введення"
        onClick={handleClick}
      />
    </div>
  );
}
```

### Передача DOM-рефів батьківським компонентам {#exposing-dom-refs-to-parent-components}

У рідкісних випадках, ви можете захотіти мати доступ до DOM-вузлів нащадків з батьківського компонента. Зазвичай так нерекомендовано робити, тому що це руйнує інкапсуляцію компонентів, але може бути використано для зміни фокусу або визначення розмірів або положення DOM-вузлів нащадка.

[Додавання рефу до класового компоненту](#adding-a-ref-to-a-class-component) - неідеальне рішення, тому що ви отримаєте посилання на екземпляр класу, а не на DOM-вузол. Також це не спрацює з функціональними компонентами.

Якщо ви користуєтеся React 16.3 або вище, ми рекомендуємо використовувати [перенаправлення рефів](/docs/forwarding-refs.html) для цих задач. **Ref forwarding lets components opt into exposing any child component's ref as their own**. Ви можете знайти детальний приклад передачі DOM-вузлів нащадків батьківському компоненту [у розділі перенаправлення рефів](/docs/forwarding-refs.html#forwarding-refs-to-dom-components).

Якщо ви користуєтеся React 16.2 або нижче, або ви потребуєте більшої гнучкості, ніж вам дає перенаправлення рефів, ви можете скористатися [альтернативним підходом](https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509) та явно передати реф як проп з іменем відмінним від `ref`.

Ми не рекомендуємо підхід передачі DOM вузлів, але він може стати рятувальним жилетом. Помітьте, що цей підхід потребує написання додаткового коду для дочірніх комопонетів. Якщо у вас взагалі немає котролю над реалізацією дочірніх компонентів, то ваш остання можливість - скористатися методом [`findDOMNode()`](/docs/react-dom.html#finddomnode), але цей метод нерекомендований та вважається застарілим у [`StrictMode`](/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage).

### Рефи зворотнього виклику {#callback-refs}

React також підтримує інший варіант ініціалізації рефів, що називається "рефи зворотнього виклику" ("callback refs"), що дає більший контроль над процесом визначення та очищення рефів.

На відміну від передачі рефа через атрибути `ref`, що створений функцією `createRef()`, ви передаєте функцію. Функція отримує екземпляр компонента чи DOM-елемент у вигляді аргумента, який можна використати або зберігти.

Приклад нижче реалізує поширений паттерн: використання функції зворотнього виклику у `ref` для отримання та зберігання посилання на DOM-вузл в екземплері.

```javascript{5,7-9,11-14,19,29,34}
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);

    this.textInput = null;

    this.setTextInputRef = element => {
      this.textInput = element;
    };

    this.focusTextInput = () => {
      // Фокусування на текстовому полі введення за допомогою нативного DOM API
      if (this.textInput) this.textInput.focus();
    };
  }

  componentDidMount() {
    // автоматичний фокус на полі введення при монтуванні
    this.focusTextInput();
  }

  render() {
    // Використання функції зворотнього виклику в `ref` для зберігання посилання на DOM-елемент
    // текстове поле введення в екземплярі (наприклад, this.textInput).
    return (
      <div>
        <input
          type="text"
          ref={this.setTextInputRef}
        />
        <input
          type="button"
          value="Фокус на текстовому полі введення"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
```

React викличе функцію зворотнього виклику `ref` з DOM-елементом, коли компонент буде вмонтований, та виконає її зі значення `null`, коли компонент буде прибрано. Рефи гарантують актуальність перед викликом метода `componentDidMount` або `componentDidUpdate`.

Ми можете передавати реф зворотнього виклику між компонентами так само, як і реф, що створюється викликом функції `React.createRef()`.

```javascript{4,13}
function CustomTextInput(props) {
  return (
    <div>
      <input ref={props.inputRef} />
    </div>
  );
}

class Parent extends React.Component {
  render() {
    return (
      <CustomTextInput
        inputRef={el => this.inputElement = el}
      />
    );
  }
}
```

У попередньому прикладі, `Parent` передає свій реф зворотнього виклику як проп `inputRef` нащадку `CustomTextInput`, і вже `CustomTextInput` передає цю функцію як спеціалізований атрибут `ref` до `<input>`. Як результат, `this.inputElement` у `Parent` буде посиланням на DOM-вузол, що відповідає елементу `<input>` у компонента `CustomTextInput`.

### Застраліле API: рядкові рефи {#legacy-api-string-refs}

Якщо ви працювали з React раніше, ви мабуть знайомі зі старим API, де атрибут `ref` може бути рядком, наприклад `"textInput"`, в той самий час DOM вузол стає доступний через `this.refs.textInput`. Ми не радимо користуватися ним, тому що рядкові рефи мають [деякі проблеми](https://github.com/facebook/react/pull/8333#issuecomment-271648615), також це API вважається застарілим, та **ймовірно буде видалено в одній з майбутніх версій**.

> Примітка
>
> Якщо ви досі користуєте `this.refs.textInput` для доступу до рефів, ми рекомендуємо натомість користовуватися [рефами зворотнього виклику](#callback-refs) або [`createRef` API](#creating-refs).

### Застереження до рефів зворотнього виклику {#caveats-with-callback-refs}

 Якщо `ref` визначено як інлайнову функцію, то вона буде виклакана двічі протягом оновлень, перший раз з `null`, потім з посиланням на DOM-елемент. Це відбувається, тому що створюється новий екземпляр функції під час кожного рендеру, так як React потребує очистити старий реф та встановити новий. Щоб запобігти цьому, просто передайте в `ref` метод класу, проте в більшості випадків це немає значення.
