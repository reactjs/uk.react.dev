---
id: react-dom
title: ReactDOM
layout: docs
category: Reference
permalink: docs/react-dom.html
---

Якщо ви завантажуєте React з `<script>` тегу, ці API високого рівня доступні на глобальній змінній `ReactDOM`. Якщо ви використовуєте ES6 з npm, ви модете написати `import ReactDOM from 'react-dom'`. Якщо ви використовуєте ES5 з npm, ви можете написати `var ReactDOM = require('react-dom')`.

## Огляд {#overview}

Пакет `react-dom` надає DOM-специфічні методи, що можуть використовуватись на верхньому рівні вашого додатку, а також як запасний спосіб аби вийти з React моделі, якщо це необхідно.В більшості ваших компонентах вам не потрібно використовувати цей модуль.

- [`render()`](#render)
- [`hydrate()`](#hydrate)
- [`unmountComponentAtNode()`](#unmountcomponentatnode)
- [`findDOMNode()`](#finddomnode)
- [`createPortal()`](#createportal)

### Підтримка браузерів {#browser-support}

React підтримує всі популярні браузери, включаючи Internet Explorer 9 та наступні, також [деякі поліфіли необхідні](/docs/javascript-environment-requirements.html) для старіших браузерів, таких як IE 9 та IE 10.

> Примітка
>
> Ми не підтримуємо старіші браузери, які не підтримують ES5 методів, але ви можете помітити, що ваш додадток працює і в старих бразуерах також якщо поліфіли такі як [es5-shim та es5-sham](https://github.com/es-shims/es5-shim) включені в сторінку. Це тільки ваш вибір, якщо ви вирішити піти цим шляхом.

* * *

## Довідка {#reference}

### `render()` {#render}

```javascript
ReactDOM.render(element, container[, callback])
```
Рендерить React елемент в наданий `container` в DOMі і повертає [рефи](/docs/more-about-refs.html) на компонент (або повертає `null` для [компонентів без стану](/docs/components-and-props.html#functional-and-class-components)).

Якщо React елемент був попердньо відрендерений в `container`, цей метод виконає його оновлення і змінить DOM за необхідністю аби відобразити останній варіант React елементу.

Якщо надано функцію зворотнього виклику, вона буде виконана після того, як компонент відрендериться або оновиться.

> Примітка:
>
> `ReactDOM.render()` контролює контент ноди контейнера, яку ви передаєте. Будь-який наявний DOM елемент всередині буде замінено під час першого виклику. Наступні виклики використовують React-овий алгоритм різниці DOM-ів для ефективних оновлень.
>
> `ReactDOM.render()` не модифікує ноду контенера (тільки модифікує дітей контейнера). Може бути також можливим вставити компонент в існуючу DOM ноду без перезапису наявних дітей.
>
> `ReactDOM.render()` наразі повертає почилання на кореневий ексземпляр `ReactComponent`. Однак використання цього значення застаріле і
> і його потрібно уникати, оскільки майбутні версії React-у можуть рендерити компоненти асинхронно в деяких випадках. Якщо вам потрібно посилання на корінь екземпляра `ReactComponent` кращим рішенням буде приєдати [рефо]
> [рефову функцію зворотнього виклику](/docs/more-about-refs.html#the-ref-callback-attribute) до коріневого елементу.
>
> Використання `ReactDOM.render()` для гідратування серверно-рендерених контейнерів заcтаріле і буде видалено в React 17. Використовуйте [`hydrate()`](#hydrate) натомість.

* * *

### `hydrate()` {#hydrate}

```javascript
ReactDOM.hydrate(element, container[, callback])
```

Такий же як [`render()`](#render), але використовується для гідрування контейнеру, HTML контент якого був відрендерений за допомогою [`ReactDOMServer`](/docs/react-dom-server.html). React буде намагтись приєднати слухачі подій до існуючого розмітки.

React очікує, що відрендерений контент ідентичний між сервером та клієнтом. Він може патчити різницю в текстовому контенті, але ви повинні трактувати незбіжності як дефекти та виправити їх. В розробницькому режимі, React попереджяє про незбіжності під час гідрування. Немає гаранті, що відмінності атрибутів будуть пропатчені у випадку незбіжності. Це важливо з точку зору продуктивності оскільки в багатьох додатках, недвіповідності рідкісні, тому валідувати всю розмітку буде непомірно затратно.

Якщо єдиний атрибут елементу чи текстовий контент неминуче різний між сервером та клієнтом (для прикладу, мітка часу), ви можете заглущити попередження додаючи `suppressHydrationWarning={true}` до елементу. Це працює тільки на першому рівні глибини, і покликане бути запасним варіантом. Не використовуйте його часто. За винятком текстового контенту, React все ж не буде намагтись пропатчити його, тому він може залишетись різним до наступних оновлень.

Якщо вам потрібно спеціально відрендерити щось по різному на сервері та на клієнті, ви можете зробити двох-прохідний рендеринг. Компоненти, що рендерять щось по-інакшому на клієнті можуть читати певну змінну на стані (для прикладу, `this.state.isClient`), якій ви можете присвоїти `true` в `componentDidMount()`. Таким чином початковий прохід рендеру відрендерить той же контент, що і на сервері, таким чином уникнувши незбіжностей, але додатковий прохід відбудеться синхронно одразу після гідрування. Зауважте, що такий підхід зробить компоненти повільнішими оскільки вони будуть рендеритись двічі, тому використовуйте такий підхід обережно.

Пам'ятайте зважати на досвід користувача в при повільному з'єднанні. JavaScript код може завантажуватись набагато пізніше, ніж початоквий HTML рендер, тому якщо ви відрендерити щось по-інакшому тільки в клієнтській частині, перехід може бути не злагоджений. Однак, якщо виконано добре, може бути корисно рендерити "оболонку" додатку на сервері, і тльки показувати деякі екстра віджети на клієнті. Для того, щоб навчитись це робити і при цьому не отримати незбіжностей в розмітці, зверніться до пояснень в попередньому параграфі.

* * *

### `unmountComponentAtNode()` {#unmountcomponentatnode}

```javascript
ReactDOM.unmountComponentAtNode(container)
```

Видаляє змонтований React компонент з DOM-у та очищує обробники подій та стран. Якщо ніякий компонент не було змонтовано в контейнер, виклик цієї функції нічого не робить. Повертає `true` якщо компонент було демонтовано та `false` якщо не було ніякого компоненту, який би можна було демонтувати.

* * *

### `findDOMNode()` {#finddomnode}

> Примітка:
>
> `findDOMNode` - це запасний спосіб, що використовувався для доступу до базової DOM ноди. В більшості випадках, використання цього запасного способу не рекомендується, оскільки він проколює абстракцію компоненту. [Він став застарілим в `StrictMode`.](/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage)

```javascript
ReactDOM.findDOMNode(component)
```
Якщо цей компонент був змонтований в DOM, цей метор поверне відповідний нативний бразерний DOM елемент. Цей метод корисний для читання значення з DOM-у, таких як значення полів форми та виконання DOM замірів. **В більшості випадках, ви можете приєднати реф до DOM ноди і взагалі уникнути використання `findDOMNode`.**

Якщо компонент рендериться в `null` або `false`, `findDOMNode` повертає `null`. Коли компонент рендериться в стрічку, `findDOMNode` повертає текстову DOM ноду, які містить значення. Починаючи з React 16, компонет може повертати фрагмент з декількома дітьми, в цьому випадку `findDOMNode` поверне DOM ноду, що відповідє першій не порожній дитині.

> Примітка:
>
> `findDOMNode` тільки працює на змонтованих компонентах (тобто таких компонентах, що були розміщені в DOM-і). Якщо ви спробуєте викликати цей метод на компоненті, який ще не було змонтовано (для прикладу, викликати `findDOMNode()` в `render()` методі компонеті, який ще тільки буде створено), то отримаєте помилку.
>
> `findDOMNode` не може використовуватись з функціональними компонентами.

* * *

### `createPortal()` {#createportal}

```javascript
ReactDOM.createPortal(child, container)
```

Створює портал. Портали надають можливість [рендерити дітей в DOM ноду, яка існує за межами ієрархії DOM компоненту](/docs/portals.html).
