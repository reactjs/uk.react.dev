---
id: react-dom
title: ReactDOM
layout: docs
category: Reference
permalink: docs/react-dom.html
---

Якщо ви завантажуєте React з `<script>` тегу, ці API високого рівня доступні на глобальній змінній `ReactDOM`. Якщо ви використовуєте ES6 з npm, ви можете написати `import ReactDOM from 'react-dom'`. Якщо ви використовуєте ES5 з npm, ви можете написати `var ReactDOM = require('react-dom')`.

## Огляд {#overview}

Пакет `react-dom` надає DOM-специфічні методи, що можуть використовуватись на верхньому рівні вашого додатку, а також як запасний спосіб аби вийти з React моделі, якщо це необхідно. В більшості ваших компонентів вам не потрібно використовувати цей модуль.

- [`render()`](#render)
- [`hydrate()`](#hydrate)
- [`unmountComponentAtNode()`](#unmountcomponentatnode)
- [`findDOMNode()`](#finddomnode)
- [`createPortal()`](#createportal)

### Підтримка браузерів {#browser-support}

React підтримує всі популярні браузери, в тому числі Internet Explorer 9 та наступні, також [деякі поліфіли необхідні](/docs/javascript-environment-requirements.html) для старіших браузерів, таких як IE 9 та IE 10.

> Примітка
>
> Ми не підтримуємо старіші браузери, які не підтримують ES5 методів, але ви можете помітити, що ваш додаток працює і в старих бразуерах також якщо поліфіли такі як [es5-shim та es5-sham](https://github.com/es-shims/es5-shim) включені в сторінку. Це тільки ваш вибір, якщо ви вирішити піти цим шляхом.

* * *

## Довідка {#reference}

### `render()` {#render}

```javascript
ReactDOM.render(element, container[, callback])
```
Рендерить React елемент в наданий `container` в DOM-і і повертає [реф](/docs/more-about-refs.html) на компонент (або повертає `null` для [компонентів без стану](/docs/components-and-props.html#functional-and-class-components)).

Якщо React елемент був попередньо відрендерений в `container`, цей метод виконає його оновлення і змінить DOM за необхідністю аби відобразити останній варіант React елементу.

Якщо надано функцію зворотнього виклику, вона буде виконана після того, як компонент відрендериться або оновиться.

> Примітка:
>
> `ReactDOM.render()` контролює контент ноди контейнера, яку ви передаєте. Будь-який наявний DOM елемент всередині буде замінено під час першого виклику. Наступні виклики використовують React-овий алгоритм різниці DOM-ів для ефективних оновлень.
>
> `ReactDOM.render()` не модифікує ноду контенера (тільки модифікує дітей контейнера). Може бути також можливим вставити компонент в наявну DOM ноду без перезапису наявних дітей.
>
> `ReactDOM.render()` наразі повертає посилання на кореневий екземпляр `ReactComponent`. Однак використання цього значення, яке повертається, застаріле і
> і його потрібно уникати, оскільки майбутні версії React-у можуть рендерити компоненти асинхронно в деяких випадках. Якщо вам потрібне посилання на корінь екземпляра `ReactComponent` кращим рішенням буде приєднати
> [рефову функцію зворотнього виклику](/docs/more-about-refs.html#the-ref-callback-attribute) до кореневого елементу.
>
> Використання `ReactDOM.render()` для гідратації серверно-рендерених контейнерів застаріле і буде видалено в React 17. Використовуйте [`hydrate()`](#hydrate) натомість.

* * *

### `hydrate()` {#hydrate}

```javascript
ReactDOM.hydrate(element, container[, callback])
```

Такий же як [`render()`](#render), але використовується для гідратації контейнеру, HTML контент якого був відрендерений за допомогою [`ReactDOMServer`](/docs/react-dom-server.html). React буде намагатись приєднати слухачі подій до наявної розмітки.

React очікує, що відрендерений контент ідентичний між сервером та клієнтом. Він може патчити різницю в текстовому контенті, але ви повинні трактувати незбіжності як дефекти та виправити їх. В розробницькому режимі, React попереджає про незбіжності під час гідратація. Немає гарантії, що відмінності атрибутів будуть пропатчені у випадку незбіжностей. Це важливо з точку зору продуктивності оскільки в багатьох додатках, невідповідності рідкісні, тому валідувати всю розмітку буде непомірно затратно.

Якщо єдиний атрибут елементу чи текстовий контент неминуче різний між сервером та клієнтом (для прикладу, мітка часу), ви можете заглушити попередження додаючи `suppressHydrationWarning={true}` до елементу. Це працює тільки на першому рівні глибини, і покликане бути запасним варіантом. Не використовуйте його часто. За винятком текстового контенту, React все ж не буде намагатись пропатчити його, тому він може залишитись різним до наступних оновлень.

Якщо вам потрібно спеціально відрендерити щось по-різному на сервері та на клієнті, ви можете зробити двох-прохідний рендеринг. Компоненти, що рендерять щось по-іншому на клієнті можуть читати певну змінну на стані (для прикладу, `this.state.isClient`), якій ви можете присвоїти `true` в `componentDidMount()`. Початковий прохід рендеру відрендерить той же контент, що і на сервері, таким чином уникнувши незбіжностей, а додатковий прохід відбудеться синхронно одразу після гідратації. Зауважте, що такий підхід зробить компоненти повільнішими, оскільки вони будуть рендеритись двічі, тому використовуйте такий підхід обережно.

Пам'ятайте зважати на досвід користувача при повільному з'єднанні. JavaScript код може завантажуватись набагато пізніше, ніж початковий HTML рендер, тому якщо ви рендерити щось по-іншому тільки в клієнтській частині, перехід може бути не злагоджений. Однак, якщо виконано добре, може бути корисно рендерити "оболонку" додатку на сервері, і тільки показувати деякі екстра віджети на клієнті. Для того, щоб навчитись це робити і при цьому не отримати незбіжностей в розмітці, зверніться до пояснень в попередньому параграфі.

* * *

### `unmountComponentAtNode()` {#unmountcomponentatnode}

```javascript
ReactDOM.unmountComponentAtNode(container)
```

Видаляє змонтований React компонент з DOM-у та очищує обробники подій та стан. Якщо ніякий компонент не було змонтовано в контейнер, виклик цієї функції нічого не робить. Повертає `true` якщо компонент було демонтовано та `false` якщо не було ніякого компоненту, який би можна було демонтувати.

* * *

### `findDOMNode()` {#finddomnode}

> Примітка:
>
> `findDOMNode` - це запасний спосіб, що використовувався для доступу до базової DOM ноди. В більшості випадках, використання цього запасного способу не рекомендується, оскільки він проколює абстракцію компоненту. [Він став застарілим в `StrictMode`.](/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage)

```javascript
ReactDOM.findDOMNode(component)
```
Якщо цей компонент був змонтований в DOM, цей метод поверне відповідний нативний браузерний DOM елемент. Цей метод корисний для читання значення з DOM-у, таких як значення полів форми та виконання DOM замірів. **В більшості випадках, ви можете приєднати реф до DOM ноди і взагалі уникнути використання `findDOMNode`.**

Якщо компонент рендериться в `null` або `false`, `findDOMNode` повертає `null`. Коли компонент рендериться в стрічку, `findDOMNode` повертає текстову DOM ноду, яка містить значення. Починаючи з React 16, компонент може повертати фрагмент з декількома дітьми, в цьому випадку `findDOMNode` поверне DOM ноду, що відповідає першій не порожній дитині.

> Примітка:
>
> `findDOMNode` тільки працює на змонтованих компонентах (тобто таких компонентах, що були розміщені в DOM-і). Якщо ви спробуєте викликати цей метод на компоненті, який ще не було змонтовано (для прикладу, викликати `findDOMNode()` в `render()` методі компоненту, який ще тільки буде створено), то отримаєте помилку.
>
> `findDOMNode` не може використовуватись з функціональними компонентами.

* * *

### `createPortal()` {#createportal}

```javascript
ReactDOM.createPortal(child, container)
```

Створює портал. Портали надають можливість [рендерити дітей в DOM ноду, яка існує за межами ієрархії DOM компоненту](/docs/portals.html).
