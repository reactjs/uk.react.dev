---
id: error-boundaries
title: Запобіжники
permalink: docs/error-boundaries.html
---

В минулому помилки JavaScript всередині компонентів призводили до пошкодження внутрішнього стану фреймворку React і спричиняли [видачу](https://github.com/facebook/react/issues/4026) [незрозумілих](https://github.com/facebook/react/issues/6895) [помилок](https://github.com/facebook/react/issues/8579) під час наступних рендерів. Ці помилки були завжди спричинені попереднью помилкою в коді програми, але React не надавав можливості вчасно опрацювати їх в компонентах, і також не міг відновитися після них.


## Представляєм запобіжники (компоненти Error Boundary) {#introducing-error-boundaries}

Помилка JavaScript в деякій частині UI не повинна ламати весь застосунок. Для вирішення цієї проблеми React версії 16 вводить для користувачів новий концепт – «запобіжник» (error boundary).

Запобіжники – це React-компоненти які **ловлять помилки JavaScript в усьому дереві своїх дочірніх компонентів, логують їх та відображають запасний UI** замість дерева компонентів, що зламалось. Запобіжники можуть ловити помилки в рендері, методах життєвого циклу та в конструкторах компонентів, що знаходяться в дереві під ними.

> Примітка
>
> Запобіжники **не можуть** піймати помилки в:
>
> * обробнику подій ([дізнатися більше](#how-about-event-handlers))
> * асинхронному коді (наприклад, функції зворотнього виклику, передані в `setTimeout` чи `requestAnimationFrame`)
> * серверному рендері (Server-side rendering)
> * самому запобіжнику (а не в його дітях)

Класовий компонент стане запобіжником якщо він задасть один (або обидва) методи життєвого циклу: [`static getDerivedStateFromError()`](/docs/react-component.html#static-getderivedstatefromerror) та [`componentDidCatch()`](/docs/react-component.html#componentdidcatch). Використовуйте `static getDerivedStateFromError()` для рендеру запасного UI після того як відбулась помилка. Використовуйте `componentDidCatch()` для логування помилки.

```js{7-10,12-15,18-21}
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Оновлюємо стан, щоб наступний рендер показав запасний UI.
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // Ви також можете передати помилку в службу звітування про помилки
    logErrorToMyService(error, info);
  }

  render() {
    if (this.state.hasError) {
      // Ви можете відрендерити будь-який власний запасний UI
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children; 
  }
}
```

Потім використовуємо запобіжник як звичайний компонент:

```js
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

Запобіжники працюють як блок `catch {}` в JavaScript але для компонентів. Лише класові компоненти можуть бути запобіжниками. На практиці в більшості випадків буде доцільно оголосити один запобіжник і потім використовувати його по всьому додатку.

Зверніть увагу, що **запобіжники можуть піймати помилки лише в компонентах, що знаходяться під ними в дереві компонентів**. Запобіжник не може піймати помилку в собі. Якщо він не зможе відрендерити повідомлення про помилку, то помилка поширеться до наступного запобіжника вище нього в дереві компонентів. Це також схоже на те, як працює блок `catch {}` в JavaScript.

## Жива демонстрація {#live-demo}

Подивіться [приклад оголошення і використання запобіжника](https://codepen.io/gaearon/pen/wqvxGa?editors=0010) в [React 16](/blog/2017/09/26/react-v16.0.html).


## Де ставити запобіжники {#where-to-place-error-boundaries}

Вирішуйте на ваш розсуд як часто ставити запобіжники. Було б доцільно обгорнути компоненти маршрутів найвищого рівня щоб показати користувачеві повідомлення «Щось пішло не так», так само, як це часто робиться в фреймворках на стороні серверу. Ви також можете обгорнути в запобіжник окремі віджети щоб захистити решту додатку від збоїв в них.


## Нова поведінка не пійманих помилок {#new-behavior-for-uncaught-errors}

Ця зміна має важливі наслідки. **Починаючи з React версії 16, помилки, які не були піймані жодним з запобіжників, призведуть до демонтування всього дерева React-компонентів.**

Ми довго обговорювали це рішення і, судячи з нашого досвіду, гірше було б залишити пошкоджений UI на місці ніж повністю його вилучити. Наприклад, в такому продукті як чат (Facebook Messenger), відображення пошкодженого UI може призвести до того, що хтось надіслав би повідомлення не тій людині. Аналогічно, ще гірше, у додатку з проведення платежів відобразити невірну суму, ніж не відобразити взагалі нічого.

Ця зміна означає, що при переході на React версії 16 ви, найбільш ймовірно, виявите існуючі збої в вашому додатку, які були непомічені до цього. Додавання запобіжників дозволить вам надати кращий досвід користувачам якщо щось піде не так.

Наприклад, Facebook Messenger огортає зміст бічної панелі, інформаційної панелі, історію повідомлень, та поле введення повідомлень в окремі запобіжники. Якщо якийсь компонент в одній з цих UI зон дасть збій, то решта зон залишаться працюючими.

Ми також рекомендуємо вам використовувати існуючі служби звітування про помилки JS (або створити власну), таким чином ви зможете дізнатись про необроблені виняткові ситуації які відбулись в production та виправити їх.


## Стек викликів компонентів {#component-stack-traces}

React 16 в режимі розробки друкує в консоль всі помилки, що відбулись під час рендеру, навіть якщо додаток ненавмисно їх поглинає. Додатково до повідомлення про помилку і стека викликів JavaScript, він також надає трасування стека компонентів. Тепер ви зможете побачити де саме в дереві компонентів відбувся збій:

<img src="../images/docs/error-boundaries-stack-trace.png" style="max-width:100%" alt="Помилка спіймана запобіжником">

Ви також зможете знайти імена файлів та номери рядків в трасуванні стека компонентів. Це працює за замовчуванням в проектах на основі [Create React App](https://github.com/facebookincubator/create-react-app):

<img src="../images/docs/error-boundaries-stack-trace-line-numbers.png" style="max-width:100%" alt="Помилка з номерами рядків спіймана запобіжником">

Якщо ви не користуєтесь Create React App, то ви можете додати вручну [цей плагін для трансформації коду](https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source) до вашої конфігурації Babel. Зверніть увагу, що він призначений лише для режиму розробки і **повинен бути відключений в production**.

> Примітка
>
> Імена компонентів, що будуть відображені в трасуванні стека, покладаються на властивість [`Function.name`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/name). Якщо ви підтримуєте старіші браузери та пристрої, в яких ця властивість ще не реалізована (наприклад, IE 11), розгляньте можливість додавання поліфілу `Function.name` в бандл вашого додатку, наприклад [`function.name-polyfill`](https://github.com/JamesMGreene/Function.name). В якості альтернативи, ви можете явно задати властивість [`displayName`](/docs/react-component.html#displayname) для всіх ваших компонентів.


## Як щодо try/catch? {#how-about-trycatch}

`try` / `catch` – чудова конструкція, але вона працює лише в імперативному коді:

```js
try {
  showButton();
} catch (error) {
  // ...
}
```

Однак React-компоненти є декларативними, вказуючи *що* повинно бути відрендерено:

```js
<Button />
```

Запобіжники зберігають декларативну природу React і ведуть себе як ви того очікуєте. Наприклад, навіть якщо помилка з'явилась під час виклику методу `componentDidUpdate`, спричиненого викликом `setState` десь глибоко в дереві, вона все рівно коректно поширеться до найближчого запобіжника.

## Як щодо обробників подій? {#how-about-event-handlers}

Запобіжники **не** ловлять помилки, що відбулись в обробниках подій.

React-у не потрібні запобіжники щоб відновитися після помилок з обробниках подій. На відміну від методу `render` та методів життєвого циклу, обробники подій не виконуються під час рендеру. Тобто, якщо виникне виняткова ситуація, React все ще знатиме що показати на екрані.

Якщо вам потрібно піймати помилку всередині обробника подій, то використовуйте звичайний JavaScript вираз `try` / `catch`:

```js{9-13,17-20}
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    try {
      // Робим щось, що може згенерувати виняткову ситуацію
    } catch (error) {
      this.setState({ error });
    }
  }

  render() {
    if (this.state.error) {
      return <h1>Сталася помилка.</h1>
    }
    return <div onClick={this.handleClick}>Натисни на мене</div>
  }
}
```

Зверніть увагу, що наведений вище приклад демонструє звичайну поведінку JavaScript і не використовує запобіжники.

## Зміна назви методу починаючи з React версії 15 {#naming-changes-from-react-15}

React версії 15 включав дуже обмежену підтримку запобіжників під іншою назвою: `unstable_handleError`. Цей метод більше не працює і вам треба буде змінити його в вашому коді на `componentDidCatch` починаючи з першого бета-випуску React версії 16.

В звязку з цими змінами ми надаємо [codemod-скрипт](https://github.com/reactjs/react-codemod#error-boundaries) для автоматизації міграції вашого коду.
