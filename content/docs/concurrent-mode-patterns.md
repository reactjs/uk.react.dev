---
id: concurrent-mode-patterns
title: Патерни паралельного UI (Експериментальні)
permalink: docs/concurrent-mode-patterns.html
prev: concurrent-mode-suspense.html
next: concurrent-mode-adoption.html
---

<style>
.scary > blockquote {
  background-color: rgba(237, 51, 21, 0.2);
  border-left-color: #ed3315;
}
</style>

<div class="scary">

>Увага:
>
>На сторінці описані **експериментальні функції, [яких ще немає](/docs/concurrent-mode-adoption.html) в стабільній версії**. Не використовуйте експериментальні збірки React у продакшн-додатках. Ці функції можуть суттєво змінитися та без попередження потрапити в React.
>
>Ця документація орієнтована на першопрохідців та зацікавлених користувачів. **Якщо ви новачок у React, не турбуйтеся про ці функції**, немає необхідності вивчати їх прямо зараз. Наприклад, якщо ви шукаєте посібник по вибірці даних, що працює вже зараз, прочитайте [цю статтю](https://www.robinwieruch.de/react-hooks-fetch-data/).

</div>

Зазвичай, коли ми оновлюємо стан, ми очікуємо негайно побачити зміни на екрані. Це має сенс, адже ми очікуємо, що наш додаток відкликатиметься на дії користувача. Тим не менше, є випадки, коли нам би хотілося **відкласти оновлення від появи на екрані**.

Наприклад, якщо ми переходимо з одної сторінки на іншу, і код або дані для наступного екрану досі не завантажились, дивитися спершу на пусту сторінку з індикатором завантаження може бути неприємно. Ми б радше хотіли затриматися на попередньому екрані. Історично, ввести такий патерн у React було складно. Паралельний режим пропонує новий набір інструментів для таких цілей.

- [Переходи](#transitions)
  - [Огортання setState у перехід](#wrapping-setstate-in-a-transition)
  - [Додавання індикатору очікування](#adding-a-pending-indicator)
  - [Перегляд змін](#reviewing-the-changes)
  - [Де стається оновлення?](#where-does-the-update-happen)
  - [Переходи — повсюду](#transitions-are-everywhere)
  - [Застосування переходів в дизайн-системі](#baking-transitions-into-the-design-system)
- [Три кроки](#the-three-steps)
  - [По замовчуванню: Відступ → Кістяк → Завершений](#default-receded-skeleton-complete)
  - [Вдосконалений: Очікування → Кістяк → Завершений](#preferred-pending-skeleton-complete)
  - [Огортання ледачих особливостей в `<Suspense>`](#wrap-lazy-features-in-suspense)
  - ["Поїзд" з затримок](#suspense-reveal-train)
  - [Відкладання індикатору завантаження](#delaying-a-pending-indicator)
  - [Підсумок](#recap)
- [Інші патерни](#other-patterns)
  - [Розділення високо- та низькоприорітетного стану](#splitting-high-and-low-priority-state)
  - [Відстрочка значення](#deferring-a-value)
  - [SuspenseList](#suspenselist)
- [Наступні кроки](#next-steps)

## Переходи {#transitions}

Давайте ще раз переглянемо [це демо](https://codesandbox.io/s/infallible-feather-xjtbu) з попередньої сторінки про [використання Suspense для завантаження даних](/docs/concurrent-mode-suspense.html).

При натисканні на кнопку "Next" для зміни активного профілю, існуюча сторінка негайно зникає, а на її місці знову з'являється індикатор завантаження. Ми називаємо це "небажаним" станом завантаження. **Було б чудово мати можливість "пропустити" його і дочекатися, поки контент завантажиться, до переходу на нову сторінку.**

Для таких цілей React пропонує новий вбудований хук `useTransition()`.

Його можна використати у три троки.

Спершу, давайте впевнимося, що ми використовуємо Паралельний режим. Більше про [застосування Паралельного режиму](/docs/concurrent-mode-adoption.html) ми поговоримо пізніше, наразі нам достатньо знати, що нам потрібно використовувати `ReactDOM.createRoot()` замість `ReactDOM.render()`, щоб ця властивість запрацювала:

```js
const rootElement = document.getElementById("root");
// Використовуємо Паралельний режим
ReactDOM.createRoot(rootElement).render(<App />);
```

Тепер імпортуємо хук `useTransition` з React:

```js
import React, { useState, useTransition, Suspense } from "react";
```

Нарешті, давайте застосуємо його в компоненті `App`:

```js{3-5}
function App() {
  const [resource, setResource] = useState(initialResource);
  const [startTransition, isPending] = useTransition({
    timeoutMs: 3000
  });
  // ...
```

**Сам по собі, цей код поки що нічого не виконує.** Нам необхідно використати значення, повертаєме даним хуком, щоб налаштувати наші переходи стану. `useTransition` повертає два значення:

* `startTransition`, що є функцією. За допомогою неї ми повідомлятимемо React оновлення *якого* стану ми хочемо відкласти.
* `isPending`, що є булевим значенням. Цим значенням React повідомляє нас про те, чи відбувається наразі перехід.

Ми використаємо його в прикладах нижче.

Зверніть увагу, що ми передаємо об'єкт конфігурації в `useTransition`. Його поле `timeoutMs`, визначає **як довго ми чекатимемо до кінця переходу**. Передавши `{timeoutMs: 3000}`, ми кажемо "якщо наступний профіль завантажиметься довше 3-х секунд, покажи великий спінер — але допоки час не мине, можна відображати попередній екран".

### Огортання setState у перехід {#wrapping-setstate-in-a-transition}

Обробник події кліку на кнопку "Next" встановлює новий активний профіль у стані:

```js{4}
<button
  onClick={() => {
    const nextUserId = getNextId(resource.userId);
    setResource(fetchProfileData(nextUserId));
  }}
>
```

Огорнемо оновлення стану в `startTransition`. Таким чином ми кажемо React, що **ми не проти відкласти оновлення стану** якщо це призведе до небажаного "стану завантаження":

```js{3,6}
<button
  onClick={() => {
    startTransition(() => {
      const nextUserId = getNextId(resource.userId);
      setResource(fetchProfileData(nextUserId));
    });
  }}
>
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/musing-driscoll-6nkie)**

Натисність "Next" декілька разів. Зверніть увагу, відчувається це вже інакше. **Замість того, щоб негайно побачити порожній екран по кліку, ми якийсь час продовжуємо бачити попередній екран.** Коли дані завантажаться, React переведе нас на інший екран.

Якщо API відповідатиме довше 5 секунд, [ми помітимо](https://codesandbox.io/s/relaxed-greider-suewh), що тепер React "здається" і все одно проходить на нову сторінку через 3 секунди. Це відбувається через те, що вже пройшов `{timeoutMs: 3000}` до `useTransition()`. Наприклад, якщо ми передамо `{timeoutMs: 60000}`, то очікування до переходу займе цілу хвилину.

### Додавання індикатору очікування {#adding-a-pending-indicator}

Досі здається, що щось не так з [нашим останнім прикладом](https://codesandbox.io/s/musing-driscoll-6nkie). Дійсно, приємно, що ми вже не бачимо "поганий" стан завантаження. **Але ж без жодного індикатору прогресу це ще гірше!** Коли ми тиснемо "Next", нічого не відбувається, і здається, ніби додаток зламався.

Наш виклик `useTransition()` повертає два значення: `startTransition` та `isPending`.

```js
  const [startTransition, isPending] = useTransition({ timeoutMs: 3000 });
```

Ми вже використали `startTransition`, щоб огорнути оновлення стану. Тепер ми також використаємо `isPending`. React представляє це булеве значення, щоб ми могли визначити, чи **очікуємо ми в даний момент завершення переходу**. Ми використаємо його, щоб відображати, що щось відбувається:

```js{4,14}
return (
  <>
    <button
      disabled={isPending}
      onClick={() => {
        startTransition(() => {
          const nextUserId = getNextId(resource.userId);
          setResource(fetchProfileData(nextUserId));
        });
      }}
    >
      Next
    </button>
    {isPending ? " Loading..." : null}
    <ProfilePage resource={resource} />
  </>
);
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/jovial-lalande-26yep)**

І тепер це виглядає значно краще! Якщо ми натиснемо Next, кнопка стане неробочою, так як багатократні кліки на неї не повинні спрацьовувати. При цьому з`явившийся напис "Loading..." каже користувачу про те, що додаток не "завис".

### Перегляд змін {#reviewing-the-changes}

Давайте ще раз переглянемо зміни, які ми зробили з [початковим прикладом](https://codesandbox.io/s/infallible-feather-xjtbu):

```js{3-5,9,11,14,19}
function App() {
  const [resource, setResource] = useState(initialResource);
  const [startTransition, isPending] = useTransition({
    timeoutMs: 3000
  });
  return (
    <>
      <button
        disabled={isPending}
        onClick={() => {
          startTransition(() => {
            const nextUserId = getNextId(resource.userId);
            setResource(fetchProfileData(nextUserId));
          });
        }}
      >
        Next
      </button>
      {isPending ? " Loading..." : null}
      <ProfilePage resource={resource} />
    </>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/jovial-lalande-26yep)**

Щоб додати переходи, ми написали всього декілька строк коду:

* Імпортували хук `useTransition` і використали його в компоненті, котрий оновлює стан.
* Передали `{timeoutMs: 3000}`, щоб залишатися на сторінці не довше 3-х секунд.
* Огорнули оновлення стану в `startTransition`, аби сказати React, що оновлення варто відкласти.
* Використали `isPending`, щоб повідомляти користувача про перехід стану і заблокувати кнопку.

В результаті, натискання "Next" не виконує негайний перехід у "небажаний" стан завантаження, а спершу залишається на попередньому екрані і там же повідомляє стосовно прогресу.

### Де стається оновлення? {#where-does-the-update-happen}

Забезпечити таку поведінку було нескладно. Проте, задумайтесь, як це взагалі може працювати, і можете трохи збитися з пантелику. Якщо ми змінюємо стан, то чому ж ми негайно не бачимо зміни? *Де* проходить наступний рендер компоненту `<ProfilePage>`?

Очевидно, обидві "версії" компоненту `<ProfilePage>` існують водночас. Ми знаємо, що стара версія існує, так як ми бачимо її на екрані і навіть відображаємо на ній індикатор завантаження. І ми знаємо, що нова версія теж *десь* існує, тому що ж ми на неї очікуємо!

**Але як дві версії того ж компоненту можуть існувати одночасно?**

Глянемо на саму суть паралельного режиму. Як ми [зазначали раніше](/docs/concurrent-mode-intro.html#intentional-loading-sequences), це виглядає так, ніби React працює над оновленням стану в "гілці". Ще один спосіб зрозуміти цей концепт — уявити, що огортаючи оновлення стану в `startTransition` оновлений компонент рендериться десь *"в паралельній реальності"*, неначе в науково-фантастичному фільмі. Ми не можемо "побачити" цю реальність напряму — проте можемо почути сигнал про те, що в ній щось відбувається  (`isPending`). Коли оновлення готове, наші "реальності" знову зливаються разом, і вже тоді ми можемо побачити результат на екрані!

Поекспериментуйте трохи більше з цим [демо](https://codesandbox.io/s/jovial-lalande-26yep) і спробуйте уявити, як це відбувається.

Звичайно, дві версії, які рендеряться *одночасно* — це тільки іллюзія, прямо як ідея того, що всі додатки на вашому комп'ютері виконуються одночасно. Насправді ж, це ваша операційна система дуже швидко перемикається між ними. Схожим чином React може перемикатися між версіями дерева, що ви бачете на екрані, або між версіями, котрі він "готує" до показу на екрані.

Такий API, як `useTransition`, дозволяє вам зосередитись на тому, що має бачити користувач, а не думати про те, як такий функціонал правильно імплементувати. І все ж таки, метафори про те, що `startTransition` виконує рендер "в іншій гілці" чи "в іншій реальності" можуть допомогти легше розуміти цей процес.

### Переходи — повсюду {#transitions-are-everywhere}

Як ми дізналися з [путівника по Паралельному режиму](/docs/concurrent-mode-suspense.html), будь-який компонент може "затриматися" в будь-який момент, якщо йому бракує якихось даних. Ми можемо стратегічно розставити перехоплювачі `<Suspense>` в різні частини дерева, щоб реагувати на такі ситуації, проте цього не завжди достатньо.

Повернемося до нашого [першого демо "затримки"](https://codesandbox.io/s/frosty-hermann-bztrp), де в нас був тільки один профіль. Зараз він завантажує дані тільки один раз. А тепер спробуємо додати кнопку "Refresh", щоб перевіряти, чи не оновилось щось на сервері.

Перша спроба виглядатиме так:

```js{6-8,13-15}
const initialResource = fetchUserAndPosts();

function ProfilePage() {
  const [resource, setResource] = useState(initialResource);

  function handleRefreshClick() {
    setResource(fetchUserAndPosts());
  }

  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails resource={resource} />
      <button onClick={handleRefreshClick}>
        Refresh
      </button>
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline resource={resource} />
      </Suspense>
    </Suspense>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/boring-shadow-100tf)**

В даному прикладі ми починаємо завантіжувати дані разом з появою компоненту, *а також* щоразу при натисканні на кнопку "Refresh". Ми поміщаємо результат виклику `fetchUserAndPosts()` в стан, щоб нижчеописані компоненти могли почати читати нові дані з тільки що відправленого запиту.

Як ми бачимо в [цьому прикладі](https://codesandbox.io/s/boring-shadow-100tf), клік на "Refresh" працює. Компоненти `<ProfileDetails>` та `<ProfileTimeline>` отримують новий проп `resource`, що представляє нові дані, а потім вони "затримуються", тому що ми досі не отримали відповіді на запит і тому ми бачимо "запасний" компонент. Коли відповідь приходить, ми бачимо оновлені пости (наш "фейковий" API додає їх кожні 3 секунди).

Проте, всі ці речі відчуваються доволі "різко". Ми тільки що переглядали сторінку, і раптом все замінилося экраном "завантаження", прямо в той момент, коли ми з нею взаємодіяли. Така поведінка дезорієнтує. **Так як і раніше, щоб уникнути небажаного "стану завантаження" ми можемо огорнути його в перехід:**

```js{2-5,9-11,21}
function ProfilePage() {
  const [startTransition, isPending] = useTransition({
    // Чекатиме 10 секунд перед тим, як показати "запасний" компонент
    timeoutMs: 10000
  });
  const [resource, setResource] = useState(initialResource);

  function handleRefreshClick() {
    startTransition(() => {
      setResource(fetchProfileData());
    });
  }

  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails resource={resource} />
      <button
        onClick={handleRefreshClick}
        disabled={isPending}
      >
        {isPending ? "Refreshing..." : "Refresh"}
      </button>
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline resource={resource} />
      </Suspense>
    </Suspense>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/sleepy-field-mohzb)**

Це вже виглядає на порядок краще! Клік на кпонку "Refresh" не переносить нас зі сторінки, яку ми переглядали. Ми бачемо, що щось завантажується "в фоні", а коли дані будуть готові — вони просто відобразяться.

### Застосування переходів в дизайн-системі {#baking-transitions-into-the-design-system}

Вже можна помітити наскільки *часто* `useTransition` може стати у пригоді. Практично будь-який клік по кнопці, чи взаємодія, що призводитиме до призупинки компоненту, повинні бути огорнуті в `useTransition`, щоб запобігти прихованню того, з чим користувач взаємодіє.

Це може призвести до безлічі повторюємого між компонентами коду. Ось чому **ми зазвичай рекомендуємо застосовувати `useTransition` прямо в компонентах *дизайн-системи* вашого додатку**. Наприклад, якщо ми хочемо винести логіку переходу у наш власний компонент `<Button>`:

```js{7-9,20,24}
function Button({ children, onClick }) {
  const [startTransition, isPending] = useTransition({
    timeoutMs: 10000
  });

  function handleClick() {
    startTransition(() => {
      onClick();
    });
  }

  const spinner = (
    // ...
  );

  return (
    <>
      <button
        onClick={handleClick}
        disabled={isPending}
      >
        {children}
      </button>
      {isPending ? spinner : null}
    </>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/modest-ritchie-iufrh)**

Зверніть увагу, що кнопку не обходить *котрий* стан ви оновлюєте. Вона огортає *всі* оновлення стану, що трапляються під час виклику обробника `onClick`, в перехід. Тепер, коли `<Button>` сам влаштовує перехід, компоненту `<ProfilePage>` не потрібно призначати власні переходи:

```js{4-6,11-13}
function ProfilePage() {
  const [resource, setResource] = useState(initialResource);

  function handleRefreshClick() {
    setResource(fetchProfileData());
  }

  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails resource={resource} />
      <Button onClick={handleRefreshClick}>
        Refresh
      </Button>
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline resource={resource} />
      </Suspense>
    </Suspense>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/modest-ritchie-iufrh)**

Натискання на кнопку почне перехід і викличе `props.onClick()` всередині нього — котрий викличе `handleRefreshClick` компонента `<ProfilePage>`. Ми починаємо завантажувати нові дані, проте "запасний" компонент не викликається, так як ми знаходимося всередині переходу, а 10-секундний перехід, зазначений в виклику `useTransition`, досі не пройшов. Поки відбувається перехід, кнопка відображатиме текстовий індикатор завантаження.

Тут в повній мірі можна побачити, як Паралельний режим допомагає добитися правильної поведінки додатку без потреби жертвувати ізоляцією і модульністю компонентів. React сам координуватиме переходом.

## Три кроки {#the-three-steps}

Ми вже оговорили всі можливі візуальні стани, через які може пройти оновлення. В цій секції ми дамо їм імена і поговоримо, як через них проходить прогрес.

<br>

<img src="../images/docs/cm-steps-simple.png" alt="Three steps" />

В самому кінці, ми знаходимося в **Завершеному** стані. Цей той стан, до якого ми хочемо в кінці кінців дістатися. Він відображається в той момент, коли новий екран вже повністю відрендерився, а нові дані більше не завантажуються.

Але перед тим, як екран опиниться в Завершеному стані, нам може бути необхідно завантажити певні дані чи код. Коли ми вже на новому екрані, але певні його частини досі завантажуються, ми називаємо це станом **Кістяку**.

Перейти до стану Кістяку можна двома способами. Проілюструємо різницю між ними на конкретних прикладах.

### По замовчуванню: Відступ → Кістяк → Завершений {#default-receded-skeleton-complete}

Відкрийте [цей приклад](https://codesandbox.io/s/prod-grass-g1lh5) і натисніть "Open Profile". Ви спостерігатимете декілька візуальних станів, один за одним:

* **Відступ**: На секунду, ви помітите запасний компонент `<h1>Loading the app...</h1>`.
* **Кістяк:** Ви побачите компонент `<ProfilePage>` з запасним компонентом `<h2>Loading posts...</h2>` всередині.
* **Завершений:** Ви побачите компонент `<ProfilePage>` без запасних компонентів всередині. Всі необхідні дані та код були завантажені.

В чому ж різниця між станом Відступу і станом Кістяку? Різниця в тому, що стан **Відступу** відчувається, ніби "крок назад", в той час як стан **Кістяку** відчувається як "крок вперед" в плані прогресу щодо відображення нового контенту.

В цьому прикладі, ми почали свій шлях з `<HomePage>`:

```js
<Suspense fallback={...}>
  {/* попередній екран */}
  <HomePage />
</Suspense>
```

Після кліку React розпочав рендерити наступний екран:

```js
<Suspense fallback={...}>
  {/* наступний екран */}
  <ProfilePage>
    <ProfileDetails />
    <Suspense fallback={...}>
      <ProfileTimeline />
    </Suspense>
  </ProfilePage>
</Suspense>
```

І `<ProfileDetails>`, і `<ProfileTimeline>` потрібні дані для рендерингу, тому вони призупиняються:

```js{4,6}
<Suspense fallback={...}>
  {/* наступний екран */}
  <ProfilePage>
    <ProfileDetails /> {/* призупиняється! */}
    <Suspense fallback={<h2>Loading posts...</h2>}>
      <ProfileTimeline /> {/* призупиняється! */}
    </Suspense>
  </ProfilePage>
</Suspense>
```

Коли компонент призупиняється, React повинен показати найближчий запасний компонент. Але найближчий запасний компонент до `<ProfileDetails>` знаходиться на верхньому рівні:

```js{2,3,7}
<Suspense fallback={
  // Ми бачимо цей запасний компонент <ProfileDetails>
  <h1>Loading the app...</h1>
}>
  {/* наступний екран */}
  <ProfilePage>
    <ProfileDetails /> {/* призупиняється! */}
    <Suspense fallback={...}>
      <ProfileTimeline />
    </Suspense>
  </ProfilePage>
</Suspense>
```

Це те, чому при кліці на кнопку здається, ніби ми "відійшли на крок назад". Перехоплювач `<Suspense>`, котрий до цього відображав корисний контент (`<HomePage />`) повинент був "відступити" і відобразити запасний компонент (`<h1>Loading the app...</h1>`). Ми називаємо це станом **Відступу**.

Коли ми завантажуємо більше даних, React спробує зрендерити ще раз, і тепер `<ProfileDetails>` може бути успішно зрендереним. В кінці кінців, ми тепер в стані **Кістяку**. Ми бачимо нову сторінку з недостаючими частинами:

```js{6,7,9}
<Suspense fallback={...}>
  {/* наступний екран */}
  <ProfilePage>
    <ProfileDetails />
    <Suspense fallback={
      // Ми зараз бачимо запасний компонент через <ProfileTimeline>
      <h2>Loading posts...</h2>
    }>
      <ProfileTimeline /> {/* призупиняється! */}
    </Suspense>
  </ProfilePage>
</Suspense>
```

В кінці кінців, вони також завантажаться, і ми побачимо **Завершений** стан.

Цей сценарій (Відступ → Кістяк → Завершений) є сценарієм по замовчуванню. Тим не менше, стан Відступу може здаватися неприємним, так як він "ховає" вже існуючу інформацію. Тому React дозволяє також використати іншу послідовність (**Очікування** → Кістяк → Завершений) за допомогою `useTransition`.

### Вдосконалений: Очікування → Кістяк → Завершений {#preferred-pending-skeleton-complete}

Коли ми використовуємо `useTransition`, React дає нам "затриматися" на попередньому екрані — і на ньому ж відобразить індикатор завантаження. Ми називаємо це станом **Очікування**. Це виглядає куди краще, ніж стан Відступу, так як нічого з існуючого контенту не зникає, а сторінка залишається доступною для взаємодії.

Можете порівняти ці два приклади, щоб відчути різницю:

* По замовчуванню: [Відступ → Кістяк → Завершений](https://codesandbox.io/s/prod-grass-g1lh5)
* **Вдосконалений: [Очікування → Кістяк → Завершений](https://codesandbox.io/s/focused-snow-xbkvl)**

Едина різниця між цими двома прикладами в тому, що перший використовує прості кнопки `<button>`, а другий — компоненти `<Button>` з `useTransition` "під капотом".

### Огортання ледачих особливостей в `<Suspense>` {#wrap-lazy-features-in-suspense}

Відкрийте [цей приклад](https://codesandbox.io/s/nameless-butterfly-fkw5q). Натиснувши на кнопку, ви ще на секунду побачите стан очікування перед тим, як перейти. Такий перехід виглядає плавно та приємно.

Додамо нову особливість на нашу сторінку — список цікавих фактів про персонажа:

```js{8,13-25}
function ProfilePage({ resource }) {
  return (
    <>
      <ProfileDetails resource={resource} />
      <Suspense fallback={<h2>Loading posts...</h2>}>
        <ProfileTimeline resource={resource} />
      </Suspense>
      <ProfileTrivia resource={resource} />
    </>
  );
}

function ProfileTrivia({ resource }) {
  const trivia = resource.trivia.read();
  return (
    <>
      <h2>Fun Facts</h2>
      <ul>
        {trivia.map(fact => (
          <li key={fact.id}>{fact.text}</li>
        ))}
      </ul>
    </>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/focused-mountain-uhkzg)**

Якщо ви зараз натиснете на "Open Profile", то помітите що щось не так. Перехід тепер займає цілих 7 секунд! Вся справа в тому, що наш API занадто повільний. Давайте припустимо, що прискорити наш API ми не можемо. Як же ми можемо покращити враження користувачів, маючи такі обмеження?

Якщо ми не хочете надовго залишатися в стані переходу, першою ідеєю буде поставити менше значення `timeoutMs` в `useTransition`, наприклад, `3000`. Можете спробувати поглянути на ефект [тут](https://codesandbox.io/s/practical-kowalevski-kpjg4). Це допоможе уникнути довгого стану Очікування, але ж ми досі не відображатимемо нічого корисного!

Є простіший спосіб вирішити цю проблему. **Замість того, щоб робити перехід коротшим, ми можемо "відключити" повільний компонент від переходу**, огорнувши його в `<Suspense>`:

```js{8,10}
function ProfilePage({ resource }) {
  return (
    <>
      <ProfileDetails resource={resource} />
      <Suspense fallback={<h2>Loading posts...</h2>}>
        <ProfileTimeline resource={resource} />
      </Suspense>
      <Suspense fallback={<h2>Loading fun facts...</h2>}>
        <ProfileTrivia resource={resource} />
      </Suspense>
    </>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/condescending-shape-s6694)**

Тут розкриється важлива деталь. React завжди намагається перейти в стан Кістяка якомога швидше. Навіть якщо ми повсюду розкладемо переходи з довгими тайм-аутами, React не буде залишатися в стані переходу довше, ніж потрібно, щоб уникнути стану Відступу.

**Якщо якась з особливостей не є життево важливою частиною нового екрану, огорніть її в `<Suspense>` і дайте їй оновлятися "ледачо".** Це дасть нам можливіть показати решту контенту якомога швидше. І навпаки, якщо екран *не варто показувати* без певного компоненту, наприклад `<ProfileDetails>` в нашому прикладі, *не* огортайте його в `<Suspense>`. Тоді переходи будуть "очікувати" допоки такий компонент буде готовим.

### "Поїзд" з затримок {#suspense-reveal-train}

Коли ми вже перейшли на наступний екран, інколи дані, необхідні для "розблокування" того чи іншого перехоплювача `<Suspense>`, прилітатимуть в швидкій послідовності. Наприклад, дві різні відповіді можуть прийти, відповідно, через 1000 мс and 1050 мс. Якщо ви вже відчекали секунду, очукування ще в 50 мс навряд чи матиме значення. Саме тому React розкриває перехоплювачі `<Suspense>` по розпорядку, неначе "поїзд", який періодично приїзджає. Тим самим ми позбуваємося неочікуваної появи і "ривків" елементів на сторінці ціною невеликої затримки.

Демо цього процесу можна побачити [тут](https://codesandbox.io/s/admiring-mendeleev-y54mk). Відповіді сервера з "цитатами" та "цікавими фактами" приходять з затримкою в 100ms один від одного. Проте React складає їх воєдино і "розкриває" їх перехоплювачі Suspense одночасно. 

### Відкладання індикатору завантаження {#delaying-a-pending-indicator}

При натисканні, компонент `Button` негайно відобразить індикатор стану Очікування:

```js{2,13}
function Button({ children, onClick }) {
  const [startTransition, isPending] = useTransition({
    timeoutMs: 10000
  });

  // ...

  return (
    <>
      <button onClick={handleClick} disabled={isPending}>
        {children}
      </button>
      {isPending ? spinner : null}
    </>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/floral-thunder-iy826)**

Це дасть користувачу знати, що якась робота вже відбувається. Тим не менше, якщо перехід радше короткий (менше за 500 ми), такий ефект може дратувати, або навіть примусити перехід здаватися *повільнішим*.

Для протидії цьому, можна спробувати *відкласти сам спінер* від відображення:

```css
.DelayedSpinner {
  animation: 0s linear 0.5s forwards makeVisible;
  visibility: hidden;
}

@keyframes makeVisible {
  to {
    visibility: visible;
  }
}
```

```js{2-4,10}
const spinner = (
  <span className="DelayedSpinner">
    {/* ... */}
  </span>
);

return (
  <>
    <button onClick={handleClick}>{children}</button>
    {isPending ? spinner : null}
  </>
);
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/gallant-spence-l6wbk)**

Після цих змін, навіть знаходячись у стані переходу ми не відображаємо ніяких індикацій, допоки не пройде 500 мс. На перший погляд, це не виглядає як велике покращення, так як відповіді API досі повільні. Але порівняйте, як це відчувалось [до](https://codesandbox.io/s/thirsty-liskov-1ygph) і [після](https://codesandbox.io/s/hardcore-http-s18xr), коли виклик API став швидким. Не дивлячись на те, що решта коду не змінилася, стримування "занадто швидкого" стану завантаження в підсвідомості покращуватиме швидкодію завдяки зменшенню уваги на затримку.

### Підсумок {#recap}

Найважливіші речі, які ми вже вивчили, це:

* По замовчуванню, порядок завантаження виглядає як Відступ → Кістяк → Завершений.
* Стан Відступу виглядає неприємно, так як під час нього приховується існуючий контент.
* Завдяки `useTransition` ми можемо показати стан Очікування замість стану Відступу. Це також дозволяє залишатися на тому ж екрані, поки новий екран готується до відображення.
* Якщо ми не хочемо, щоб певні компоненти перешкоджали переходу, ми можемо огорнути їх у їх власні перехоплювачі `<Suspense>`.
* Замість того, щоб використовувати `useTransition` в кожному компоненті, ми можемо інтегрувати їх у свою дизайн-систему.

## Інші патерни {#other-patterns}

Переходи — це, напевно, найбільш часто використовуємий патерн Паралельного режиму, проте є ще декілька інших, які також можуть стати у нагоді.

### Розділення високо- та низькоприорітетного стану {#splitting-high-and-low-priority-state}

Коли ви проектуєте React-компоненти, найкращою практикою, зазвичай, є пошук "мінімального представлення" стану. Наприклад, замість того, щоб тримати `firstName`, `lastName` та `fullName` в стані, як правило, легше зберігати в ньому тільки `firstName` та `lastName`, а потім розраховувати `fullName` під час рендерінгу. Це допоможе нам уникнути помилок, таких як оновлення потрібного стану в одних випадках, але не в інших.

Тим не менше, у Паралельному режимі є випадки, коли вам може бути *потрібно* "дублювати" деякі дані в окремі змінні стану. Розгляньте цей маленький додаток-перекладач:

```js
const initialQuery = "Hello, world";
const initialResource = fetchTranslation(initialQuery);

function App() {
  const [query, setQuery] = useState(initialQuery);
  const [resource, setResource] = useState(initialResource);

  function handleChange(e) {
    const value = e.target.value;
    setQuery(value);
    setResource(fetchTranslation(value));
  }

  return (
    <>
      <input
        value={query}
        onChange={handleChange}
      />
      <Suspense fallback={<p>Loading...</p>}>
        <Translation resource={resource} />
      </Suspense>
    </>
  );
}

function Translation({ resource }) {
  return (
    <p>
      <b>{resource.read()}</b>
    </p>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/brave-villani-ypxvf)**

Зверніть увагу, що при введені тексту компонент `<Translation>` затримується, і ми бачимо запасний компонент `<p>Loading...</p>` допоки не з'являться оновлені дані. Це не ідеально. Було б значно приємніше, якби ми продовжували бачити *попередній* переклад трохи довше, поки ми отримуємо новий.

До речі, якщо відкрити консоль, то можна побачити попередження:

```
Warning: App triggered a user-blocking update that suspended.

The fix is to split the update into multiple parts: a user-blocking update to provide immediate feedback, and another update that triggers the bulk of the changes.

Refer to the documentation for useTransition to learn how to implement this pattern.
```

Як ми вже вказували раніше, якщо якесь оновлення стану спричиняє затримку компоненту, таке оновлення стану слід огортати в перехід. Додамо `useTransition` в наш компонент:

```js{4-6,10,13}
function App() {
  const [query, setQuery] = useState(initialQuery);
  const [resource, setResource] = useState(initialResource);
  const [startTransition, isPending] = useTransition({
    timeoutMs: 5000
  });

  function handleChange(e) {
    const value = e.target.value;
    startTransition(() => {
      setQuery(value);
      setResource(fetchTranslation(value));
    });
  }

  // ...

}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/zen-keldysh-rifos)**

Спробуйте ввести текст в поле. Щось не так! Значення оновлюється дуже повільно.

Ми виправили першу проблему (затримку поза переходом). Проте тепер через перехід наш стан не оновлюється негайно, і він не може "впливати" на контролюєме поле вводу!

Цю проблему можна вирішити **розбиттям стану на дві частини:** "високоприорітетну" частину, що робить оновлення негайно, та "низькоприорітетну" частину, що чекатиме на завершення переходу.

В нашому випадку вже є дві змінні стану. Введений текст знаходиться в `query`, а переклад ми читаємо з `resource`. Ми хочемо, щоб зміни в стані `query` відбувалися негайно, а зміни в `resource` (наприклад, отримання перекладу) викликали перехід.

Тому для вирішення проблеми ми поставимо `setQuery` (котрий не затримується) *поза* переходом, а `setResource` (котрий затримується) *в* переході.

```js{4,5}
function handleChange(e) {
  const value = e.target.value;
  
  // Поза переходом (термінове оновлення)
  setQuery(value);

  startTransition(() => {
    // В переході (можна відкласти)
    setResource(fetchTranslation(value));
  });
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/lively-smoke-fdf93)**

Після цієї зміни все працюватиме так, як і очікується. Ми можемо без затримок вводити дані в текстове поле, а переклад пізніше "наздожене" всі введені зміни.

### Відстрочка значення {#deferring-a-value}

По замовчуванно, React завжди рендерить послідовний UI. Погляньте на цей код:

```js
<>
  <ProfileDetails user={user} />
  <ProfileTimeline user={user} />
</>
```

React забезпечує те, що коли б ми не глянули на ці компоненти, вони завжди відображатимуть дані з одного і того ж об'єкту `user`. Якщо стан оновиться і компонентам передаватиметься інакший `user`, компоненти так само одночасно оновляться. Навіть якщо ви зробите запис екрану, ви не зможете знайти кадр, де ці компоненти показували б дані з різних об'єктів `user`. (Якщо ж у вас вдасться відтворити щось подібне — киньте нам баг!)

В більшості випадків це має сенс. Непослідовний UI може збити користувачів з пантелику. (Наприклад, було в жахливо, якби в мессенджері кнопка "Відправити" і панель для вибору бесіди "сперечалися б" стосовно того, який з тредів зараз відкрито.)

Тим не менше, інколи дійсно потрібно намірено створити таку непослідовність. Це можна зробити вручну, "розділивши" стан, як це показувалося в прикладах вище, проте React також має вбудований хук для таких цілей:

```js
import { useDeferredValue } from 'react';

const deferredValue = useDeferredValue(value, {
  timeoutMs: 5000
});
```

Щоб продемонструвати дану особливість, використаємо [цей приклад з профілями, що можна перемикати](https://codesandbox.io/s/musing-ramanujan-bgw2o). Натисніть на кнопку "Next" і зверніть увагу, що зміна профілю займає 1 секунду.

Тепер припустимо, що користувацькі дані отримуються дуже швидко і це займає всього 300 мілісекунд. Наразі ми очікуємо цілу секунду, тому що нам потрібно, щоб і деталі, і цитати користувача відображалися послідовно на сторінці профілю. Але що якщо ми хочемо швидше відобразити дані користувача?

Якщо ми готові пожертвувати послідовністю, ми можемо **передати потенційно застарілі дані в компоненти, що затримають наш перехід**. З цим нам допоможе `useDeferredValue()`:

```js{2-4,10,11,21}
function ProfilePage({ resource }) {
  const deferredResource = useDeferredValue(resource, {
    timeoutMs: 1000
  });
  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails resource={resource} />
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline
          resource={deferredResource}
          isStale={deferredResource !== resource}
        />
      </Suspense>
    </Suspense>
  );
}

function ProfileTimeline({ isStale, resource }) {
  const posts = resource.posts.read();
  return (
    <ul style={{ opacity: isStale ? 0.7 : 1 }}>
      {posts.map(post => (
        <li key={post.id}>{post.text}</li>
      ))}
    </ul>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/vigorous-keller-3ed2b)**

Компроміс в тому, що `<ProfileTimeline>` буде непослідовним щодо інших компонентів і потенційно може відображати попередні дані. Натисніть "Next" декілька разів і ви це помітите. Але, дякуючи цьому, ми змогли скоротити час переходу з 1000 мс до 300 мс.

Те, чи є такий компроміс доречним, залежить від конкретної ситуації. Тим не менше, це зручний інструмент, особливо, коли зміни між пунктами не сильно помітні, а користувач може навіть не здогадуватися що він ще секунду дивиться на застарілу версію.

Варто звернути увагу, що `useDeferredValue` зручний не *тільки* при отриманні даних. Він може стати в нагоді, якщо "важке" дерево компонентів робить взаємодії (такі як введення тексту в поле) розпливчатими. Так само, як ми можемо "відкласти" значення, що занадто довго отримується (і показати застаріле значення, не взираючи на те, що інші компоненти оновлюються), так само ми можемо поступати з деревами, які занадто довго рендеряться.

Наприклад, уявіть собі такий фільтруємий список:

```js
function App() {
  const [text, setText] = useState("hello");

  function handleChange(e) {
    setText(e.target.value);
  }

  return (
    <div className="App">
      <label>
        Type into the input:{" "}
        <input value={text} onChange={handleChange} />
      </label>
      ...
      <MySlowList text={text} />
    </div>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/pensive-shirley-wkp46)**

В цьому прикладі **кожен елемент в `<MySlowList>` штучно сповільнено — кожен з них блокує наступні на кілька мілісекунд**. Ми б ніколи не робили такого в реальному додатку, але цей приклад допоможе нам симулювати те, що відбувається в глубокому дереві компонентів, де немає явного простору для оптимізацій.

Можна помітити, як введення тексту спричиняє ривки. Давайте додамо `useDeferredValue`:

```js{3-5,18}
function App() {
  const [text, setText] = useState("hello");
  const deferredText = useDeferredValue(text, {
    timeoutMs: 5000
  });

  function handleChange(e) {
    setText(e.target.value);
  }

  return (
    <div className="App">
      <label>
        Type into the input:{" "}
        <input value={text} onChange={handleChange} />
      </label>
      ...
      <MySlowList text={deferredText} />
    </div>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/infallible-dewdney-9fkv9)**

Тепер ривків при вводі куди менше — хоча ми і заплатили за це тим, що дозволили результатам з'являтися з затримкою.

В чому різниця між цим підходом та debounce? В нашому прикладі є визначена штучна затримка (3 мс для кожного з 80 елементів), тому затримка буде завжди, невзираючи на потужність комп'ютера. В той же час, значення `useDeferredValue` "відстає" тільки якщо рендеринг займає час. Сам React не накладає мінімального лагу. В більш реалістичних умовах ви можете розраховувати, що продовжуємість лагу залежатиме від пристрою користувача. На інших пристроях лаг може бути коротшим, або його може взагалі не бути, а на повільних пристроях він буде більш помітним. Але в обох випадках додаток буде відкликатися. В тому і перевага цього механізму над debouncing чи throttling, які завжди створюватимуть мінімальну затримку і не можуть запобігти блокуванню потоку під час рендерингу.

Не дивлячись на те, що покращення в швидкодії вже помітні, цей приклад досі виглядає не дуже переконливо, так як Паралельному режиму бракує деяких критично важливих оптимізацій для цього випадку. Тим не менше, цікаво побачити, що такі особливості як `useDeferredValue` (чи `useTransition`) можна використовувати не тільки очікуючи на відповідь сервера, а і для роботи з "важкими" розрахунковими операціями.

### SuspenseList {#suspenselist}

`<SuspenseList>` — це останній патерн для організації станів завантаження.

Розгляньте цей приклад:

```js{5-10}
function ProfilePage({ resource }) {
  return (
    <>
      <ProfileDetails resource={resource} />
      <Suspense fallback={<h2>Loading posts...</h2>}>
        <ProfileTimeline resource={resource} />
      </Suspense>
      <Suspense fallback={<h2>Loading fun facts...</h2>}>
        <ProfileTrivia resource={resource} />
      </Suspense>
    </>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/proud-tree-exg5t)**

Час на виклик API в цьому прикладі обирається раптовим чином. Спробуйте перезавантижити декілька разів і помітите, що інколи цитати героїв завантажуються першими, а інколи "цікаві факти" йдуть першими.

Тут прихована проблема. Якщо відповідь з цікавими фактами прийде першою, ми побачимо цікаві факти під запасним компонентом `<h2>Loading posts...</h2>`, де мали бути цитати. Ми можемо почати їх читати, проте коли прийде відповідь сервера з *цитатами*, всі цікаві факти рухнуть вниз. І це ламає сприйняття інтерфейсу.

Один зі способів це вирішити — просто перенести це в один перехоплювач:

```js
<Suspense fallback={<h2>Loading posts and fun facts...</h2>}>
  <ProfileTimeline resource={resource} />
  <ProfileTrivia resource={resource} />
</Suspense>
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/currying-violet-5jsiy)**

Проблема з цим підходом в тому, що тепер ми *завжди* чекатимемо, поки обидва запити пройдуть. В той же час, якщо *цитати* приходять першими, то в нас немає причин відкладати їх відображення. Якщо цікаві факти завантажаться пізніше, вони все одно не зсунуть всю розмітку, тому що вони завжди будуть під цитатами.

Інші підходи, наприклад, розкладання промісів спеціальним чином, буде помітно складніше відмінити, коли стани завантаження знаходяться в різних компонентах дерева.

Щоб вирішити цю проблему, імпортуємо `SuspenseList`:

```js
import { SuspenseList } from 'react';
```

`<SuspenseList>` координує "порядок розкриття" найближчих під собою нод `<Suspense>`:

```js{3,11}
function ProfilePage({ resource }) {
  return (
    <SuspenseList revealOrder="forwards">
      <ProfileDetails resource={resource} />
      <Suspense fallback={<h2>Loading posts...</h2>}>
        <ProfileTimeline resource={resource} />
      </Suspense>
      <Suspense fallback={<h2>Loading fun facts...</h2>}>
        <ProfileTrivia resource={resource} />
      </Suspense>
    </SuspenseList>
  );
}
```

**[Спробуйте на CodeSandbox](https://codesandbox.io/s/black-wind-byilt)**

Опція `revealOrder="forwards"` означає, що найближчі ноди `<Suspense>` всередині списку **будуть "розкривати" свій контент тільки в порядку, з яким вони з'являються в дереві елементів — навіть якщо дані для них з'являтимуться в іншому порядку**. `<SuspenseList>` має і інакші цікаві опції: спробуйте змінити `"forwards"` на `"backwards"` або `"together"` і подивіться, що вийде.

Ви можете контролювати, скільки станів завантаження видно одночасно за допомогою пропу `tail`. Якщо ми визначимо `tail="collapsed"`, ми бачимемо *не більше одного* запасного компоненту в момент часу. Можете спробувати поекспериментувати [тут](https://codesandbox.io/s/adoring-almeida-1zzjh).

Не забувайте, що `<SuspenseList>` можна компонувати, як і все в React. Наприклад, можете створити сітку з рядків `<SuspenseList>` всередині таблиці `<SuspenseList>`.

## Наступні кроки {#next-steps}

Паралельний режим пропонує потужну модель для UI рограмування, разом з набором нових, компонуємих примітивів, щоб допомогти вам створювати інтерфейси, від взаємодії з якими ваші користувачі будуть в захваті.

Це — результат декількох років дослідно-конструкторських робіт, проте робота над ним ще не завершена. В секції [застосування Паралельного режиму](/docs/concurrent-mode-adoption.html), ми опишемо, як можна його спробувати і що від нього очікувати.
