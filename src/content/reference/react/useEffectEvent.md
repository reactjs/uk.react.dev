---
title: useEffectEvent
---

<Intro>

`useEffectEvent` це Хук React, який дозволяє винести **нереактивну логіку** з ваших Ефектів у функцію, яку можна використовувати повторно, — так звану [**Подію Ефекту**](/learn/separating-events-from-effects#declaring-an-effect-event).

```js
const onSomething = useEffectEvent(callback)
```

</Intro>

<InlineToc />

## Довідка {/*reference*/}

### `useEffectEvent(callback)` {/*useeffectevent*/}

Викликайте `useEffectEvent` на верхньому рівні вашого компонента, щоб оголосити Подію Ефекту. Події Ефекту — це функції, які ви можете викликати всередині Ефектів, таких як `useEffect`:

```js {4-6,11}
import { useEffectEvent, useEffect } from 'react';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  // ...
}
```

[Дивіться більше прикладів нижче.](#usage)

#### Параметри {/*parameters*/}

- `callback`: Функція, що містить логіку для вашої Події Ефекту. Коли ви визначаєте Подію Ефекту за допомогою `useEffectEvent`, `callback` **завжди** матиме доступ до **найновіших** значень із пропсів і стану, коли він викликається. Це допомагає уникнути проблем із "застарілими замиканнями" (stale closures).

#### Повертає {/*returns*/}

Повертає функцію Події Ефекту. Ви можете викликати цю функцію всередині `useEffect`, `useLayoutEffect` або `useInsertionEffect`.

#### Застереження {/*caveats*/}

- **Викликайте лише всередині Ефектів:** Події Ефекту слід викликати лише в Ефектах. Визначайте їх безпосередньо перед Ефектом, який їх використовує. Не передавайте їх іншим компонентам або Хукам. Лінтер [`eslint-plugin-react-hooks`](/reference/eslint-plugin-react-hooks) (версія 6.1.1 або вище) забезпечить дотримання цього обмеження, щоб запобігти виклику Подій Ефекту в неправильному контексті.
- **Це не скорочення для залежностей:** Не використовуйте `useEffectEvent`, щоб уникнути зазначення залежностей у масиві залежностей вашого Ефекту. Це може приховати помилки та ускладнити розуміння вашого коду. Віддайте перевагу явним залежностям або використовуйте refs для порівняння попередніх значень, якщо це необхідно.
- **Використовуйте для нереактивної логіки:** Використовуйте `useEffectEvent` лише для винесення логіки, яка **не залежить** від зміни значень.

___

## Використання {/*usage*/}

### Зчитування найновіших пропсів і стану {/*reading-the-latest-props-and-state*/}

Зазвичай, коли ви отримуєте доступ до реактивного значення всередині Ефекту, ви повинні включити його до масиву залежностей. Це гарантує, що ваш Ефект знову запуститься, коли це значення зміниться, що зазвичай є бажаною поведінкою.

Але в деяких випадках ви можете захотіти прочитати найновіші пропси або стан всередині Ефекту, не викликаючи повторного запуску Ефекту при зміні цих значень.

Щоб [прочитати найновіші пропси або стан](/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events) у вашому Ефекті, не роблячи ці значення реактивними, включіть їх у Подію Ефекту.

```js {7-9,12}
import { useEffect, useContext, useEffectEvent } from 'react';

function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  const onNavigate = useEffectEvent((visitedUrl) => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    onNavigate(url);
  }, [url]);

  // ...
}
```

У цьому прикладі Ефект повинен повторно запуститися після рендерингу, коли змінюється `url` (щоб зафіксувати відвідування нової сторінки), але він **не** повинен повторно запускатися, коли змінюється `numberOfItems`. Загорнувши логіку логування в Подію Ефекту, `numberOfItems` стає **нереактивним**. Він завжди береться з найновішого значення без запуску Ефекту.

Ви можете передати реактивні значення, як-от `url`, як аргументи до Події Ефекту, щоб зберегти їх реактивними, отримуючи доступ до найновіших нереактивних значень всередині події.